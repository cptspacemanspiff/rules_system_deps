# rules_system_deps

`rules_system_deps` is a small Bzlmod extension that turns host `pkg-config`
packages into Bazel repos/targets you can depend on from C/C++ and Go (cgo).

## What it provides

- `pkg_config_ext.lib(name, pkg)`: creates a repo named `@<name>` with target
  `@<name>//:<name>` that exports include paths/defines/link flags.
- `pkg_config_ext.go_profile(name, libs)`: creates Go wrapper macros in
  `@pkg_config_go//:defs.bzl`, such as `go_library_<name>`, that auto-inject
  `cdeps` for cgo targets. `libs` can be full labels (recommended), or
  shorthand names from `lib(name = ...)`.

## Prerequisites

- `pkg-config` installed
- system dev packages installed for each requested library
  (for example `libgtk-4-dev` / `gtk4-devel`)

## C/C++ usage

### `MODULE.bazel`

```starlark
module(name = "my_project")

bazel_dep(name = "rules_system_deps", version = "0.0.1")
bazel_dep(name = "rules_cc", version = "0.2.14")

sys_libs = use_extension("@rules_system_deps//extensions:extensions.bzl", "pkg_config_ext")
sys_libs.lib(name = "pci", pkg = "libpci")
use_repo(sys_libs, "pci")
```

### `BUILD.bazel`

```starlark
load("@rules_cc//cc:defs.bzl", "cc_binary")

cc_binary(
    name = "main",
    srcs = ["main.c"],
    deps = ["@pci//:pci"],
)
```

## Go/cgo usage

For Go, you still use Gazelle `go_deps.gazelle_override(...)`, but the
macro implementation comes from generated repo `@pkg_config_go`.

### `MODULE.bazel`

```starlark
module(name = "my_go_project")

bazel_dep(name = "rules_system_deps", version = "0.0.1")
bazel_dep(name = "rules_cc", version = "0.2.14")
bazel_dep(name = "rules_go", version = "0.60.0")
bazel_dep(name = "gazelle", version = "0.46.0")

sys_libs = use_extension("@rules_system_deps//extensions:extensions.bzl", "pkg_config_ext")
sys_libs.lib(name = "glib", pkg = "glib-2.0")
sys_libs.lib(name = "gtk4", pkg = "gtk4")
sys_libs.go_profile(name = "gtk4", libs = ["@glib//:glib", "@gtk4//:gtk4"])
use_repo(sys_libs, "glib", "gtk4", "pkg_config_go")

go_sdk = use_extension("@rules_go//go:extensions.bzl", "go_sdk")
go_sdk.download(version = "1.24.0")

go_deps = use_extension("@gazelle//:extensions.bzl", "go_deps")
go_deps.from_file(go_mod = "//:go.mod")

# Make @pkg_config_go visible inside repos generated by go_deps.
inject_repo(go_deps, "pkg_config_go")

go_deps.gazelle_override(
    path = "github.com/diamondburned/gotk4/pkg",
    directives = [
        "gazelle:map_kind go_library go_library_gtk4 @pkg_config_go//:defs.bzl",
    ],
)

use_repo(go_deps, "com_github_diamondburned_gotk4_pkg")
```

### Why `map_kind` + `directives` are needed

Gazelle normally generates `go_library(...)` for upstream Go packages.
`map_kind` tells Gazelle to emit your wrapper macro instead:

- from kind: `go_library`
- to kind: `go_library_gtk4`
- implementation file: `@pkg_config_go//:defs.bzl`

That wrapper adds GTK/glib `cdeps` automatically when `cgo = True`, so
generated cgo packages can find headers like `glib.h`.

## Using `inject_repo` with Bazel-built libraries

`inject_repo` is a Bzlmod built-in that makes a repo—one that a module extension does not own—visible to that extension. You need it when a `go_profile` dep lives in the root module (or another module), rather than in a `lib()`-generated repo.

### When you need it

`go_profile(libs = [...])` accepts any Bazel label, including targets from repos that `rules_system_deps` did not create. If such a repo is owned by a different extension (or by the root module itself), the `pkg_config_ext` extension cannot see it unless you call `inject_repo`.

Common cases:
- The library was built by Bazel (e.g. `bazel_dep(name = "libwebp")`) rather than discovered via `pkg-config`.
- The library target lives in the root module's own `BUILD.bazel`.

### Worked example: Bazel-built libwebp

In `examples/go_webp/MODULE.bazel`, `libwebp` is a Bazel-built dep, not a system package. Its `cc_library` target is `@go_webp_example//:webp` (defined in the root module). To use it in a `go_profile`, the root module injects itself into `sys_libs`:

```starlark
bazel_dep(name = "libwebp", version = "1.6.0")

sys_libs = use_extension("@rules_system_deps//extensions:extensions.bzl", "pkg_config_ext")
inject_repo(sys_libs, "go_webp_example")          # expose root module's repo to the extension
sys_libs.go_profile(name = "webp", libs = ["@go_webp_example//:webp"])
use_repo(sys_libs, "pkg_config_go")
```

Without `inject_repo(sys_libs, "go_webp_example")`, the extension would fail because `@go_webp_example` is outside its visibility.

The second `inject_repo` in the same file makes `@pkg_config_go` visible to the `go_deps` extension (so Gazelle's `map_kind` can find `@pkg_config_go//:defs.bzl`). That is the same pattern shown in the GTK4 example above.

## Multiple Go profiles

You can define multiple independent cdep sets:

```starlark
sys_libs.go_profile(name = "gtk4", libs = ["@glib//:glib", "@gtk4//:gtk4"])
sys_libs.go_profile(name = "adwaita", libs = ["@glib//:glib", "@gtk4//:gtk4", "@libadwaita//:libadwaita"])
```

You can also point at regular `cc_library` targets, not only pkg-config repos,
for example `"//third_party/gtk_shim:gtk_shim"`.

Then map different upstream modules to different wrappers, for example
`go_library_gtk4` vs `go_library_adwaita`.

## Example

- Go GTK4 sample: `examples/go_gtk4`
- Go WebP sample (Bazel-built libwebp): `examples/go_webp`
- Basic C sample: `examples/basic`

## Troubleshooting

- `fatal error: glib.h: No such file or directory`
  - Make sure system dev packages are installed and your Go module uses a
    mapped wrapper (`map_kind`) that injects the right `cdeps`.
- `unknown repo 'pkg_config_go' ... from ... go_deps ...`
  - Add `inject_repo(go_deps, "pkg_config_go")` in `MODULE.bazel`.
- `pkg-config --cflags ... failed`
  - Verify package name (`pkg`) matches host `pkg-config --list-all` output.
