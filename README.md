# bazel_pkg_config

`bazel_pkg_config` is a small Bzlmod extension that turns host `pkg-config`
packages into Bazel repos/targets you can depend on from C/C++ and Go (cgo).

## What it provides

- `pkg_config_ext.lib(name, pkg)`: creates a repo named `@<name>` with target
  `@<name>//:<name>` that exports include paths/defines/link flags.
- `pkg_config_ext.go_profile(name, libs)`: creates Go wrapper macros in
  `@pkg_config_go//:defs.bzl`, such as `go_library_<name>`, that auto-inject
  `cdeps` for cgo targets.

## Prerequisites

- `pkg-config` installed
- system dev packages installed for each requested library
  (for example `libgtk-4-dev` / `gtk4-devel`)

## C/C++ usage

### `MODULE.bazel`

```starlark
module(name = "my_project")

bazel_dep(name = "bazel_pkg_config", version = "0.0.1")
bazel_dep(name = "rules_cc", version = "0.2.14")

sys_libs = use_extension("@bazel_pkg_config//extensions:extensions.bzl", "pkg_config_ext")
sys_libs.lib(name = "pci", pkg = "libpci")
use_repo(sys_libs, "pci")
```

### `BUILD.bazel`

```starlark
load("@rules_cc//cc:defs.bzl", "cc_binary")

cc_binary(
    name = "main",
    srcs = ["main.c"],
    deps = ["@pci//:pci"],
)
```

## Go/cgo usage

For Go, you still use Gazelle `go_deps.gazelle_override(...)`, but the
macro implementation comes from generated repo `@pkg_config_go`.

### `MODULE.bazel`

```starlark
module(name = "my_go_project")

bazel_dep(name = "bazel_pkg_config", version = "0.0.1")
bazel_dep(name = "rules_cc", version = "0.2.14")
bazel_dep(name = "rules_go", version = "0.60.0")
bazel_dep(name = "gazelle", version = "0.46.0")

sys_libs = use_extension("@bazel_pkg_config//extensions:extensions.bzl", "pkg_config_ext")
sys_libs.lib(name = "glib", pkg = "glib-2.0")
sys_libs.lib(name = "gtk4", pkg = "gtk4")
sys_libs.go_profile(name = "gtk4", libs = ["glib", "gtk4"])
use_repo(sys_libs, "glib", "gtk4", "pkg_config_go")

go_sdk = use_extension("@rules_go//go:extensions.bzl", "go_sdk")
go_sdk.download(version = "1.24.0")

go_deps = use_extension("@gazelle//:extensions.bzl", "go_deps")
go_deps.from_file(go_mod = "//:go.mod")

# Make @pkg_config_go visible inside repos generated by go_deps.
inject_repo(go_deps, "pkg_config_go")

go_deps.gazelle_override(
    path = "github.com/diamondburned/gotk4/pkg",
    directives = [
        "gazelle:map_kind go_library go_library_gtk4 @pkg_config_go//:defs.bzl",
    ],
)

use_repo(go_deps, "com_github_diamondburned_gotk4_pkg")
```

### Why `map_kind` + `directives` are needed

Gazelle normally generates `go_library(...)` for upstream Go packages.
`map_kind` tells Gazelle to emit your wrapper macro instead:

- from kind: `go_library`
- to kind: `go_library_gtk4`
- implementation file: `@pkg_config_go//:defs.bzl`

That wrapper adds GTK/glib `cdeps` automatically when `cgo = True`, so
generated cgo packages can find headers like `glib.h`.

## Multiple Go profiles

You can define multiple independent cdep sets:

```starlark
sys_libs.go_profile(name = "gtk4", libs = ["glib", "gtk4"])
sys_libs.go_profile(name = "adwaita", libs = ["glib", "gtk4", "libadwaita"])
```

Then map different upstream modules to different wrappers, for example
`go_library_gtk4` vs `go_library_adwaita`.

## Example

- Go GTK4 sample: `examples/go_gtk4`
- Basic C sample: `examples/basic`

## Troubleshooting

- `fatal error: glib.h: No such file or directory`
  - Make sure system dev packages are installed and your Go module uses a
    mapped wrapper (`map_kind`) that injects the right `cdeps`.
- `unknown repo 'pkg_config_go' ... from ... go_deps ...`
  - Add `inject_repo(go_deps, "pkg_config_go")` in `MODULE.bazel`.
- `pkg-config --cflags ... failed`
  - Verify package name (`pkg`) matches host `pkg-config --list-all` output.
