"""Repository rule that queries pkg-config and exports flags as a .bzl file."""

def _parse_flags(flags_str, prefix):
    """Extract values with given prefix (e.g. '-I', '-l', '-L') from a flags string."""
    return [f[len(prefix):] for f in flags_str.split(" ") if f.startswith(prefix)]

def _pkg_config_impl(rctx):
    pkg = rctx.attr.pkg

    # Check that pkg-config is available before trying to use it.
    which = rctx.execute(["which", "pkg-config"])
    if which.return_code != 0:
        fail(
            "\n\nERROR: pkg-config is not installed or not on PATH.\n" +
            "  Required to resolve system dependency: '{}'\n".format(pkg) +
            "  Install it with your system package manager, e.g.:\n" +
            "    Fedora/RHEL:  sudo dnf install pkgconf-pkg-config\n" +
            "    Debian/Ubuntu: sudo apt install pkg-config\n" +
            "    macOS:        brew install pkg-config\n",
        )

    # Check the package exists before querying flags, to give a clear error.
    exists = rctx.execute(["pkg-config", "--exists", pkg])
    if exists.return_code != 0:
        # Collect the list of known packages to help the user find the right name.
        known = rctx.execute(["pkg-config", "--list-all"])
        hint = ""
        if known.return_code == 0:
            # Look for packages whose name contains any word from pkg.
            candidates = []
            pkg_words = pkg.replace("-", " ").replace("_", " ").lower().split()
            for line in known.stdout.splitlines():
                name = line.split(" ")[0].lower()
                if any([w in name for w in pkg_words]):
                    candidates.append(line.split(" ")[0])
            if candidates:
                hint = "\n  Similar packages found:\n" + "\n".join(["    " + c for c in candidates[:8]])
        fail(
            "\n\nERROR: pkg-config package '{}' not found on this system.\n".format(pkg) +
            "  Install the development package, e.g.:\n" +
            "    Fedora/RHEL:  sudo dnf install {}-devel\n".format(pkg) +
            "    Debian/Ubuntu: sudo apt install lib{}-dev\n".format(pkg) +
            hint + "\n",
        )

    result = rctx.execute(["pkg-config", "--cflags", pkg])
    if result.return_code != 0:
        fail("\n\nERROR: pkg-config --cflags '{}' failed:\n  {}\n".format(pkg, result.stderr.strip()))
    cflags = result.stdout.strip()

    result = rctx.execute(["pkg-config", "--libs", pkg])
    if result.return_code != 0:
        fail("\n\nERROR: pkg-config --libs '{}' failed:\n  {}\n".format(pkg, result.stderr.strip()))
    libs = result.stdout.strip()

    includes = _parse_flags(cflags, "-I")
    defines = _parse_flags(cflags, "-D")
    linkopts_l = ["-l" + l for l in _parse_flags(libs, "-l")]
    linkopts_L = ["-L" + l for l in _parse_flags(libs, "-L")]

    # pkg-config omits -L for standard paths, but hermetic toolchains need them.
    if not linkopts_L:
        result = rctx.execute(["pkg-config", "--variable=libdir", pkg])
        if result.return_code == 0 and result.stdout.strip():
            linkopts_L = ["-L" + result.stdout.strip()]
    other_copts = [f for f in cflags.split(" ") if f and not f.startswith("-I") and not f.startswith("-D")]

    # Write a .bzl file exporting the flags as constants.
    # INCLUDES are absolute system include paths (propagates to dependents via -isystem).
    # COPTS are other flags like -pthread, -msse.
    bzl_content = """\
# Auto-generated by pkg_config repository rule for "{pkg}".
# Do not edit.
INCLUDES = {includes}
COPTS = {copts}
DEFINES = {defines}
LINKOPTS = {linkopts}
""".format(
        pkg = pkg,
        includes = repr(includes),
        copts = repr(other_copts),
        defines = repr(defines),
        linkopts = repr(linkopts_L + linkopts_l),
    )

    build_content = """\
# Auto-generated by pkg_config repository rule for "{pkg}".
# Do not edit.
load("@rules_system_deps//private:system_library.bzl", "system_library")

system_library(
    name = "{name}",
    includes = {includes},
    defines = {defines},
    linkopts = {linkopts},
    visibility = ["//visibility:public"],
)
""".format(
        pkg = pkg,
        name = rctx.attr.target_name,
        includes = repr(includes),
        defines = repr(defines),
        linkopts = repr(linkopts_L + linkopts_l),
    )

    rctx.file("flags.bzl", bzl_content)
    rctx.file("BUILD.bazel", build_content)

pkg_config = repository_rule(
    implementation = _pkg_config_impl,
    attrs = {
        "pkg": attr.string(mandatory = True, doc = "pkg-config package name"),
        "target_name": attr.string(mandatory = True, doc = "Target name in generated BUILD file"),
    },
    local = True,
    doc = "Queries pkg-config and exports flags as a .bzl file.",
)
