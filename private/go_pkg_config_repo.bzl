"""Repository rule that generates go_library wrappers for pkg-config deps."""

def _parse_spec(spec):
    parts = spec.split("|", 1)
    if len(parts) != 2:
        fail(
            "\n\nERROR: Invalid go_profile spec: '{}'\n".format(spec) +
            "  Expected format: '<profile_name>|<dep1>,<dep2>,...'\n" +
            "  Example: 'gtk4|@@glib//:glib,@@gtk4//:gtk4'\n",
        )
    profile = parts[0]
    if not profile:
        fail(
            "\n\nERROR: go_profile spec has an empty profile name: '{}'\n".format(spec) +
            "  The profile name is the part before the '|'.\n",
        )
    deps = [dep for dep in parts[1].split(",") if dep]
    if not deps:
        fail(
            "\n\nERROR: go_profile '{}' has no dependencies listed after the '|'.\n".format(profile) +
            "  Specify at least one dep, e.g.: sys_libs.go_profile(name='{}', libs=['@@somerepo//:sometarget'])\n".format(profile),
        )
    return profile, deps

def _go_pkg_config_impl(rctx):
    profile_deps = {}
    all_deps = []

    for spec in rctx.attr.profile_specs:
        profile, deps = _parse_spec(spec)
        if profile in profile_deps:
            fail(
                "\n\nERROR: Duplicate go_profile name: '{}'\n".format(profile) +
                "  Each go_profile must have a unique name.\n",
            )
        profile_deps[profile] = deps
        for dep in deps:
            if dep not in all_deps:
                all_deps.append(dep)

    build_lines = [
        "# Auto-generated by go_pkg_config repository rule.",
        "# Do not edit.",
        "",
    ]

    # Use aliases in this repo so generated defs.bzl can always refer to local labels.
    dep_alias = {}
    for idx, dep in enumerate(all_deps):
        alias_name = "cdep_{}".format(idx)
        dep_alias[dep] = alias_name
        build_lines.extend([
            "alias(",
            "    name = \"{}\",".format(alias_name),
            "    actual = \"{}\",".format(dep),
            "    visibility = [\"//visibility:public\"],",
            ")",
            "",
        ])

    build_lines.extend([
        "exports_files([\"defs.bzl\"])",
        "",
    ])

    defs_lines = [
        '"""Auto-generated go_library wrappers for pkg-config cdeps."""',
        "",
        "load(\"@@rules_go+//go:def.bzl\", _go_library = \"go_library\")",
        "",
        "def _go_library_with_cdeps(extra_cdeps, name, cgo = False, cdeps = None, **kwargs):",
        "    merged_cdeps = list(cdeps or [])",
        "    if cgo:",
        "        for dep in extra_cdeps:",
        "            if dep not in merged_cdeps:",
        "                merged_cdeps.append(dep)",
        "    _go_library(name = name, cgo = cgo, cdeps = merged_cdeps, **kwargs)",
        "",
    ]

    for profile in sorted(profile_deps.keys()):
        cdeps = ["Label(\"//:{}\")".format(dep_alias[dep]) for dep in profile_deps[profile]]
        defs_lines.extend([
            "def go_library_{}(name, **kwargs):".format(profile),
            "    _go_library_with_cdeps([{}], name, **kwargs)".format(", ".join(cdeps)),
            "",
        ])

    rctx.file("BUILD.bazel", "\n".join(build_lines))
    rctx.file("defs.bzl", "\n".join(defs_lines))

go_pkg_config = repository_rule(
    implementation = _go_pkg_config_impl,
    attrs = {
        "profile_specs": attr.string_list(
            mandatory = True,
            doc = "List of '<profile>|<dep1,dep2,...>' specs.",
        ),
    },
    local = True,
    doc = "Generates go_library wrapper macros backed by pkg-config cdeps.",
)
